---
title: GitHub Repository Conventions
description: Standards and workflows for contributing to Mosaic on GitHub.
---

Building a sustainable engine isn‚Äôt just about how we write code‚Äîit‚Äôs also about **how we collaborate around that code**. Issues, branches, commits, pull requests, and automation form the connective tissue of the project. If those are messy, the codebase will eventually follow.

These conventions define how we use GitHub in Mosaic. They exist to keep collaboration predictable, reduce cognitive overhead, and make it easier for both newcomers and long-term contributors to work effectively without stepping on each other‚Äôs toes.

As with our C++ conventions, these rules are not theoretical. They‚Äôre shaped by real friction points we want to avoid as the project grows.

---

## The Philosophy Behind Our Workflow

GitHub is not just a hosting platform‚Äîit‚Äôs a **shared communication layer**. Every commit message, branch name, label, and PR description is part of how contributors understand intent, scope, and impact.

Our guiding principles are:

- **Clarity over cleverness**
- **Consistency over personal preference**
- **Automation where it removes human error**
- **Low barrier to entry for new contributors**

If something can be inferred automatically, we structure our workflow so tools can infer it. If something needs human judgment, we make that judgment explicit and visible.

---

## Commits and Branches: Structured Intent

We follow two complementary standards:

- **Conventional Commits**
  https://www.conventionalcommits.org/en/v1.0.0/#summary
- **Conventional Branch Names**
  https://conventional-branch.github.io/

### Why This Matters

Structured commits and branches allow us to:
- Understand *what changed* and *why* without reading diffs
- Generate changelogs automatically
- Reason about breaking changes
- Keep history readable months or years later

### Commit Messages

Every commit message must follow the Conventional Commits format:

```

type(scope): short description

```

Examples:
```

feat(renderer): add bindless texture support
fix(ecs): prevent dangling entity handles
docs(engine): clarify renderer initialization order

```

Breaking changes **must** be explicitly marked according to the specification.

### Branch Names

Branches follow the same intent-driven structure:

```

type/scope/short-description

```

Examples:
```

feat/graphics/shadow-mapping
fix/core/thread-race
docs/architecture/ecs-overview

```

This makes it immediately obvious what a branch is about *before* opening a PR.

---

## Issues and Labels: A Shared Vocabulary

Labels are the backbone of how we reason about work in Mosaic. They encode **what something is**, **where it belongs**, **its urgency**, **its state**, and **its scope**‚Äîall at a glance.

We deliberately use a **rich but structured label taxonomy**. This avoids overloading single labels with too much meaning and allows automation, filtering, and triage to scale as the project grows.

---

### üì¶ Packages

Package labels identify **which deliverable or artifact** is affected. These are especially important because Mosaic is a multi-package repository.

<div style={{display: "flex", flexWrap: "wrap", gap: "8px"}}>
  {[
    "Codex",
    "docsgen",
    "metagen",
    "Editor",
    "Testbed",
    "Mosaic Engine",
  ].map(p => (
    <span style={{background:"#D8D1FB",color:"black",padding:"4px 8px",borderRadius:"6px"}}>
      {`Package: ${p}`}
    </span>
  ))}
</div>

Use **exactly one** package label whenever possible. If an issue truly spans multiple packages, that should be explicitly justified in the description.

---

### üß± Departments (Subsystem Ownership)

Department labels indicate **which technical area owns the work**. They are used for routing, review assignment, and long-term accountability.

<div style={{display: "flex", flexWrap: "wrap", gap: "8px"}}>
  {[
    "CI/CD",
    "Core Systems",
    "Documentation",
    "ECS",
    "Graphics",
    "Testing",
    "Tooling",
    "Translations",
    "Dependencies",
  ].map(d => (
    <span style={{background:"#0075CA",color:"white",padding:"4px 8px",borderRadius:"6px"}}>
      {`Department: ${d}`}
    </span>
  ))}
</div>

Department labels answer the question:
**‚ÄúWho should care about this?‚Äù**

---

### üñ• Platforms

Platform labels specify **where the issue manifests or applies**. They are critical for cross-platform correctness and regression tracking.

<div style={{display: "flex", flexWrap: "wrap", gap: "8px"}}>
  {["Android","Linux","Web","Windows"].map(p => (
    <span style={{background:"#ddb6e5",color:"black",padding:"4px 8px",borderRadius:"6px"}}>
      {`Platform: ${p}`}
    </span>
  ))}
</div>

If a problem is platform-agnostic, no platform label is required.

---

### üö¶ Priority

Priority expresses **urgency and impact**, not personal interest or convenience.

<div style={{display: "flex", flexWrap: "wrap", gap: "8px"}}>
  <span style={{background:"#FF0000",color:"white",padding:"4px 8px",borderRadius:"6px"}}>Priority: Critical</span>
  <span style={{background:"#FF6500",color:"white",padding:"4px 8px",borderRadius:"6px"}}>Priority: High</span>
  <span style={{background:"#FFBF00",color:"black",padding:"4px 8px",borderRadius:"6px"}}>Priority: Medium</span>
  <span style={{background:"#099A50",color:"white",padding:"4px 8px",borderRadius:"6px"}}>Priority: Low</span>
</div>

Priority should be assigned during triage, not guessed by default.

---

### üìå Status (Lifecycle Tracking)

Status labels describe **where an issue or PR is in its lifecycle**. Only one status label should be active at a time.

<div style={{display: "flex", flexWrap: "wrap", gap: "8px"}}>
  <span style={{background:"#050505",color:"white",padding:"4px 8px",borderRadius:"6px"}}>Status: Abandoned</span>
  <span style={{background:"#099A50",color:"white",padding:"4px 8px",borderRadius:"6px"}}>Status: Accepted</span>
  <span style={{background:"#80FFA3",color:"black",padding:"4px 8px",borderRadius:"6px"}}>Status: Available</span>
  <span style={{background:"#FF0000",color:"white",padding:"4px 8px",borderRadius:"6px"}}>Status: Blocked</span>
  <span style={{background:"#009B97",color:"white",padding:"4px 8px",borderRadius:"6px"}}>Status: Completed</span>
  <span style={{background:"#D5D5D5",color:"black",padding:"4px 8px",borderRadius:"6px"}}>Status: In Progress</span>
  <span style={{background:"#FF0000",color:"white",padding:"4px 8px",borderRadius:"6px"}}>Status: On Hold</span>
  <span style={{background:"#FFFB80",color:"black",padding:"4px 8px",borderRadius:"6px"}}>Status: Pending</span>
  <span style={{background:"#000000",color:"white",padding:"4px 8px",borderRadius:"6px"}}>Status: Refused</span>
  <span style={{background:"#FFBF00",color:"black",padding:"4px 8px",borderRadius:"6px"}}>Status: Review Needed</span>
  <span style={{background:"#FF0000",color:"white",padding:"4px 8px",borderRadius:"6px"}}>Status: Revision Needed</span>
  <span style={{background:"#6B1375",color:"white",padding:"4px 8px",borderRadius:"6px"}}>Status: Triaged</span>
</div>

Status labels answer:
**‚ÄúWhat is happening with this right now?‚Äù**

---

### üß≠ Type (Intent of the Work)

Type labels classify **what kind of work** an issue or PR represents.

<div style={{display: "flex", flexWrap: "wrap", gap: "8px"}}>
  <span style={{background:"#FF0000",color:"white",padding:"4px 8px",borderRadius:"6px"}}>Type: Bug</span>
  <span style={{background:"#4B26C9",color:"white",padding:"4px 8px",borderRadius:"6px"}}>Type: Development</span>
  <span style={{background:"#A2EEEF",color:"black",padding:"4px 8px",borderRadius:"6px"}}>Type: Enhancement</span>
  <span style={{background:"#33CB51",color:"white",padding:"4px 8px",borderRadius:"6px"}}>Type: Feature</span>
  <span style={{background:"#FFBF00",color:"black",padding:"4px 8px",borderRadius:"6px"}}>Type: Maintenance</span>
  <span style={{background:"#D876E3",color:"white",padding:"4px 8px",borderRadius:"6px"}}>Type: Question</span>
</div>

Type labels answer:
**‚ÄúWhat kind of change is this?‚Äù**

---

### üå± Contribution-Friendly Defaults

These labels have **special meaning on GitHub** and are intentionally preserved.

<div style={{display: "flex", flexWrap: "wrap", gap: "8px"}}>
  <span style={{background:"#7057ff",color:"white",padding:"4px 8px",borderRadius:"6px"}}>good first issue</span>
  <span style={{background:"#006B75",color:"white",padding:"4px 8px",borderRadius:"6px"}}>help wanted</span>
</div>

* **good first issue** ‚Äî Curated for newcomers, with clear scope and guidance
* **help wanted** ‚Äî Maintainers actively welcome external contributions

---

### ü§ñ Automation & Dependabot

The following labels are **used automatically** by Dependabot and related tooling:

<div style={{display: "flex", flexWrap: "wrap", gap: "8px"}}>
  <span style={{background:"#000000",color:"white",padding:"4px 8px",borderRadius:"6px"}}>github_actions</span>
  <span style={{background:"#000000",color:"white",padding:"4px 8px",borderRadius:"6px"}}>dart</span>
</div>

Do not remove or repurpose these labels‚Äîthey are part of the automation pipeline.

---

### Labeling Philosophy (Important)

Not every issue needs every label.

**Typical minimum set:**

* 1 √ó `Type`
* 1 √ó `Status`
* 1 √ó `Package`
* Optional: `Department`, `Platform`, `Priority`

Labels are not decoration‚Äîthey are **structured metadata**. When used consistently, they make large-scale maintenance and triage possible without meetings or spreadsheets.

---

## Issue and Pull Request Templates

We **strongly recommend** using the provided **issue and pull request templates**, especially if you‚Äôre new to the project.

Templates exist to:
- Ask the right questions up front
- Reduce back-and-forth clarification
- Make issues actionable
- Keep reviews focused on substance, not missing context

If you‚Äôre experienced, templates still save time. If you‚Äôre new, they act as guardrails.

---

## Automation and Dependency Management

### Dependabot

Mosaic uses **Dependabot** to keep dependencies up to date for:

- **VCPKG** (C++ dependencies)
- **pub.dev** (Dart / Flutter tooling)

Automated PRs are labeled appropriately and should be reviewed like any other change. We don‚Äôt blindly merge dependency updates‚Äî**we verify integration and impact**.

---

### Claude Code Integration

The repository includes a **Claude Code integration** to assist with:
- Code exploration
- Refactoring assistance
- Understanding unfamiliar subsystems

This tool is intended to **augment contributor productivity**, not replace engineering judgment. Generated suggestions must be reviewed with the same care as human-written code.

---

## Pre-Commit Hooks: Automated Code Quality Checks

Mosaic uses **pre-commit hooks** to enforce code quality standards automatically before commits are created. This removes the burden of manual formatting and style checks, freeing contributors to focus on logic and design.

### Why We Use Pre-Commit Hooks

Pre-commit hooks:
- **Catch formatting issues early** ‚Äî Before they're committed and picked up in reviews
- **Enforce consistency** ‚Äî Same standards applied everywhere, regardless of IDE or personal preference
- **Save CI/CD time** ‚Äî Issues are fixed locally, not discovered in pipelines
- **Reduce review friction** ‚Äî Reviewers focus on substance, not whitespace
- **Lower barrier to entry** ‚Äî New contributors get automatic guidance without configuration

Think of pre-commit hooks as a **helpful gatekeeper**‚Äîthey ensure basic hygiene while letting your engineering judgment flow freely.

### Setting Up Pre-Commit Hooks

#### Installation

Pre-commit hooks require the `pre-commit` framework to be installed:

```bash
pip install pre-commit
```

(Or if using `uv` for package management: `uv pip install pre-commit`)

#### Activating Hooks in Your Repository

Run this command once in your local Mosaic clone:

```bash
pre-commit install
```

This installs git hooks into your `.git/hooks/` directory. From now on, `pre-commit` runs automatically before every commit.

#### Verifying Installation

To manually check that hooks are installed and working:

```bash
pre-commit run --all-files
```

This runs all hooks against every file in the repository (useful after installation to see if any existing violations need fixing).

### Hook Categories

#### 1. General Code Hygiene

These hooks catch universal code quality issues across all files.

| Hook | Purpose | Files | Auto-Fix |
|------|---------|-------|----------|
| `trailing-whitespace` | Remove trailing spaces at end of lines | All files | Yes |
| `end-of-file-fixer` | Ensure files end with exactly one newline | All files | Yes |
| `check-yaml` | Validate YAML syntax in config files | `*.yaml`, `*.yml` | No |
| `check-added-large-files` | Prevent accidentally committing large binaries | All files | No |

**What to do if a check fails:** For auto-fix hooks (trailing-whitespace, end-of-file-fixer), re-stage the corrected files and commit again. For validation hooks (check-yaml, check-added-large-files), read the error message and fix the underlying issue.

#### 2. Python Linting and Formatting (Ruff)

These hooks enforce Python code quality in the `scripts/` directory using **Ruff**, a fast, modern Python linter and formatter.

| Hook | Purpose | Files | Auto-Fix |
|------|---------|-------|----------|
| `ruff-check` | Lint Python code for errors and style issues | `scripts/**/*.py` | Yes (with `--fix`) |
| `ruff-format` | Auto-format Python code consistently | `scripts/**/*.py` | Yes |

**What happens:** When you commit Python files in `scripts/`, both hooks run. `ruff-check --fix` automatically fixes fixable issues (import sorting, unused variables, etc.). `ruff-format` ensures consistent indentation and spacing. Both are non-blocking if issues remain unfixed.

**Troubleshooting:** If `ruff-check` fails with unfixable issues, the error message will specify the problem. Consult the Ruff documentation for your specific rule code.

#### 3. C/C++ Formatting (Clang-Format)

This hook enforces consistent C/C++ formatting across the engine using **Clang-Format**, configured to match Mosaic's style guide.

| Hook | Purpose | Files | Auto-Fix |
|------|---------|-------|----------|
| `clang-format` | Auto-format C/C++ code according to `.clang-format` config | `mosaic/`, `testbed/`, `pieces/`, `codex/`, `docsgen/` | Yes |

**Formatting Style:** Mosaic's `.clang-format` enforces:
- **Indent:** 4 spaces (no tabs)
- **Column limit:** 100 characters
- **Allman braces:** Opening braces on new lines for functions, classes, namespaces
- **Google-based style** with C++20 standard
- Pointer alignment to the left: `int* ptr` not `int *ptr`

**What happens:** When you commit C++ files in the engine directories, `clang-format` automatically reformats your code. Changes are written back to your files, and you need to re-stage them before committing.

**Example workflow:**
```bash
git add src/my_feature.cpp
git commit -m "feat(core): add async task cancellation"
# clang-format hook runs and fixes formatting
# Git prevents commit and tells you files were modified

git add src/my_feature.cpp  # Re-stage with formatting applied
git commit -m "feat(core): add async task cancellation"  # Now succeeds
```

**Skipping hooks (use sparingly):** If you genuinely need to bypass hooks (e.g., for a complex merge or special formatting requirement), use:

```bash
git commit --no-verify
```

**This should be rare.** Hooks exist to keep the codebase consistent. If you're tempted to skip frequently, talk to the team about why.

### Common Hook Scenarios

#### Scenario: I committed, but clang-format fixed my code. What do I do?

1. Review the formatting changes: `git diff HEAD`
2. If they look correct, re-stage: `git add .`
3. Amend the commit: `git commit --amend --no-edit`
4. Push as normal

#### Scenario: A hook is reporting a false positive or blocking legitimately.

Open an issue with details (the file, the hook, the output). The team can adjust hook configuration if needed.

#### Scenario: I want to run hooks manually without committing.

```bash
pre-commit run --all-files           # Run all hooks
pre-commit run clang-format          # Run specific hook
pre-commit run --files src/foo.cpp   # Run on specific file
```

#### Scenario: A hook is slow or failing mysteriously.

Check the pre-commit cache: `pre-commit clean` then `pre-commit run --all-files`.

### Disabling or Updating Hooks

Hooks are configured in `.pre-commit-config.yaml` at the repository root. Changes to this file require coordination with the team‚Äîdon't modify it without discussion.

If you believe a hook rule is incorrect or counterproductive, open an issue describing:
- Which hook
- Why it's problematic
- What you propose instead

The team reviews these requests and updates the configuration collectively.

---

## The Long View

A GitHub repository is a living system. The more contributors it attracts, the more important structure becomes. These conventions ensure that Mosaic remains:

- Approachable for newcomers
- Predictable for maintainers
- Scalable as complexity increases

The goal isn‚Äôt bureaucracy‚Äîit‚Äôs **reducing friction so energy goes into building the engine, not managing chaos**.

As the project evolves, these conventions may evolve too. When they do, they will change for the same reason they exist now: to make collaboration smoother, clearer, and more sustainable.
